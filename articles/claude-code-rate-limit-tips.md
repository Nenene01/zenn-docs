---
title: "Claude Code Proプランで5時間制限に引っかからないための運用術"
emoji: "⏱️"
type: "tech"
topics: ["claudecode", "ai", "開発効率化", "運用"]
published: false
---

## はじめに

Claude Code（Proプラン）を使ってアプリ開発を進めていたところ、**5時間のレート制限**にちょくちょく引っかかるようになりました。

「あと少しで完了するのに...」というタイミングで制限に引っかかると、かなりストレスです。

この記事では、レート制限を回避しつつ効率的に開発を進めるための運用術をまとめます。

## Claude Code のレート制限について

### Proプランの制限

Claude Code Proプランには、5時間あたりの使用量制限があります。

- **対象**: APIコール数、トークン消費量
- **リセット**: 5時間ごとにローリングリセット
- **超過時**: 一時的に利用制限

### なぜ制限に引っかかるのか

私の場合、以下が原因でした：

1. **サブエージェントの多用** - コード変更のたびにbiome-checkerを起動
2. **大量のコンテキスト** - 長いセッションで会話履歴が肥大化
3. **探索的な作業** - 「これ試して」「やっぱりこっち」の繰り返し
4. **並列実行** - 複数ファイルへの同時処理

---

## 対策1: `/usage` コマンドで使用量を監視

### 使い方

```
/usage
```

現在の使用量と残り容量を確認できます。

### 運用のコツ

- **作業開始時に確認** - 残り容量を把握してから作業開始
- **大きなタスク前に確認** - リファクタリングや大量編集の前にチェック
- **制限が近づいたら休憩** - 無理に続けず、リセットを待つ

### 目安

| 残り容量 | 推奨アクション |
|---------|--------------|
| 80%以上 | 通常作業OK |
| 50-80% | 大きなタスクは控える |
| 30%以下 | 必要最小限の作業のみ |
| 10%以下 | 作業を中断、リセットを待つ |

---

## 対策2: `/clear` でコンテキストをリセット

### 問題

長いセッションでは会話履歴が肥大化し、毎回のリクエストでトークンを大量消費します。

### 使い方

```
/clear
```

**セッションの会話履歴のみ**をクリアして、トークン消費を抑えます。

### `/clear` の影響範囲

```
/clear で消えるもの:
├── ✅ 会話履歴（今回のセッションでの対話）
└── ✅ 一時的なコンテキスト

/clear でも残るもの:
├── ❌ CLAUDE.md（永続メモリ）
├── ❌ rules/*.md（プロジェクトルール）
└── ❌ settings.json の設定
```

つまり、`/clear` は「会話のリセット」であり、**プロジェクト設定や永続メモリは影響を受けません**。

### いつ使うか

- **タスクが完了したとき** - 新しいタスクに移る前にクリア
- **セッションが1時間を超えたとき** - 定期的にリフレッシュ
- **エラーループに陥ったとき** - 一度リセットして再開
- **無関係な会話が続いたとき** - コンテキストをスッキリさせる

### 注意点

- クリアすると過去の会話内容を参照できなくなる
- **ただし、CLAUDE.md や rules/ に記載した情報は残る**
- 重要な決定事項は `/memory`（CLAUDE.md）に記載しておけば安心

---

## 対策3: `/memory` で重要情報を永続化

### `/memory` コマンドとは

```
/memory
```

このコマンドを実行すると、**システムエディタでCLAUDE.mdファイルが開きます**。

### 実行時に表示される内容

`/memory` を実行すると、以下のファイルが表示されます：

```
読み込まれるメモリ（優先度順）:

1. プロジェクトルール    ./.claude/rules/*.md
2. プロジェクトメモリ    ./.claude/CLAUDE.md または ./CLAUDE.md
3. ユーザールール        ~/.claude/rules/*.md
4. ユーザーメモリ        ~/.claude/CLAUDE.md
5. ローカルメモリ        ./CLAUDE.local.md (個人用)
```

つまり、**CLAUDE.mdだけでなく、rulesディレクトリ内のすべての.mdファイルも「メモリ」として扱われます**。

### なぜ rules ディレクトリが表示されるのか

Claude Codeは**階層的なメモリ管理システム**を採用しています。

```
.claude/
├── CLAUDE.md              # メインのメモリ（統合インストラクション）
└── rules/
    ├── code-style.md      # コードスタイルルール
    ├── api-rules.md       # API開発ルール
    └── testing.md         # テスト規約
```

**rulesディレクトリのメリット:**
- **モジュール化** - 1ファイル1トピックで管理しやすい
- **パス指定** - 特定ファイルにのみ適用可能（`globs`設定）
- **チーム共有** - Gitで管理してチーム全体で共有

### `/memory` と `/clear` の違い

**重要**: この2つは全く異なる目的を持っています。

| コマンド | 対象 | 効果 | 永続性 |
|---------|------|------|--------|
| `/memory` | CLAUDE.md ファイル | メモリを編集 | **永続的** |
| `/clear` | セッションの会話履歴 | 会話をリセット | セッション限定 |

```
/clear の影響範囲:
├── 会話履歴        ✅ クリアされる
├── CLAUDE.md       ❌ 影響なし（永続）
└── rules/*.md      ❌ 影響なし（永続）
```

つまり、**`/clear` しても `/memory` で設定した内容は消えません**。
次のセッションでも自動的に読み込まれます。

### メモリの永続化の仕組み

Claude Codeのメモリは**ファイルベース**で永続化されます。

1. **CLAUDE.md** - テキストファイルとして保存
2. **rules/*.md** - 各ファイルが独立して保存
3. **Git管理可能** - チームで共有できる

```bash
# メモリを編集
> /memory
# → エディタが開く → 編集して保存

# セッションをクリア（メモリは残る）
> /clear

# 新しいセッションでも同じメモリにアクセス可能
```

### 運用フロー

1. 作業開始時: `/memory` で現在の設定を確認
2. プロジェクト設定: CLAUDE.md にコマンドやルールを記載
3. 詳細ルール: rules/ にモジュール化して配置
4. `/clear` で会話履歴をリセット（メモリは保持される）

### 保存すべき情報

CLAUDE.md に記載すべき情報：

- **プロジェクトの技術スタック** - フレームワーク、DB、API
- **よく使うコマンド** - build, test, lint など
- **ディレクトリ構造の概要**
- **コーディング規約**

rules/ に分割すべき情報：

- **API開発ルール** - api-rules.md
- **フロントエンド規約** - frontend-rules.md
- **テスト規約** - testing-rules.md

---

## 対策4: claude-mem プラグインの活用

### 概要

[claude-mem](https://github.com/thedotmack/claude-mem) は、Claude Codeの会話履歴やメモリを管理するプラグインです。

### 主な機能

- **セッション履歴の永続化** - 過去のセッションを参照可能
- **コンテキストの自動要約** - 重要な情報を圧縮して保持
- **セマンティック検索** - 過去の会話から関連情報を検索

### インストール

```bash
# プラグインのインストール（詳細は公式リポジトリを参照）
```

### 活用のコツ

- **セッション開始時**: 過去のコンテキストを自動で読み込み
- **長時間作業時**: 定期的に要約を保存
- **プロジェクト切り替え時**: コンテキストを分離管理

---

## 対策5: Skills/Rules でコンテキストを最適化

### 問題

毎回同じ説明をするとトークンを消費します。

### 解決策

プロジェクト固有のルールやスキルを `.claude/` ディレクトリに定義します。

### ディレクトリ構成

```
.claude/
├── CLAUDE.md          # プロジェクト概要
├── settings.json      # ルール設定
├── rules/             # 開発ルール
│   ├── rules.md       # 基本ルール
│   └── api-rules.md   # API開発ルール
├── commands/          # カスタムスキル
│   └── db-apply.md    # DB適用スキル
└── agents/            # サブエージェント
    └── biome-checker.md
```

### 効果

- **説明の省略** - ルールに書いてあるので毎回説明不要
- **一貫性** - 同じ指示を繰り返さない
- **効率化** - よく使う操作をスキル化

### 例: CLAUDE.md

```markdown
# プロジェクト概要

- フレームワーク: Next.js 14 (App Router)
- データベース: Cloudflare D1
- API: Hono
- Linter: Biome

## コマンド

- `npm run check` - lint + format
- `npm run type-check` - 型チェック
- `npm run db:apply` - DB適用
```

これにより、毎回「このプロジェクトはNext.jsで...」と説明する必要がなくなります。

---

## 対策6: サブエージェントの使用を控える

### 問題

サブエージェントは便利ですが、呼び出すたびにトークンを消費します。

### 解決策

- **プロアクティブな呼び出しを無効化** - 自動呼び出しを控える
- **直接コマンドを優先** - `npm run check` を直接実行
- **並列実行を制限** - 最大3プロセスに制限

詳細は別記事を参照:
https://zenn.dev/nenene01/articles/claude-code-agent-best-practices

---

## 対策7: 効率的な指示の出し方

### 悪い例（トークン消費大）

```
このファイルを見て、問題があれば教えて。
あ、やっぱりこっちのファイルも見て。
ついでにこれも修正して。
```

### 良い例（トークン消費小）

```
以下のファイルを確認し、lint/型エラーがあれば修正してください:
- src/components/Header.tsx
- src/components/Footer.tsx

修正後、`npm run check` を実行して結果を報告してください。
```

### コツ

1. **明確な指示** - 何をしてほしいか具体的に
2. **まとめて依頼** - 小出しにしない
3. **完了条件を明示** - 「〜したら完了」を伝える
4. **探索的作業を避ける** - 事前に方針を決めてから依頼

---

## 対策8: セッション管理のベストプラクティス

### 推奨フロー

```
1. 作業開始
   └─ /usage で残り容量を確認
   └─ /memory で前回の状態を確認

2. 作業中
   └─ 1時間ごとに /usage で確認
   └─ 重要な決定は /memory に保存
   └─ タスク完了ごとに /clear を検討

3. 作業終了
   └─ 作業状態を /memory に保存
   └─ /clear でセッションをクリア
   └─ 正しく終了 (/exit)
```

### 時間配分の目安

| 時間 | アクション |
|------|-----------|
| 0:00 | 作業開始、/usage確認 |
| 0:30 | 中間確認 |
| 1:00 | /clear検討、/memory保存 |
| 1:30 | 必要に応じて休憩 |
| 2:00 | /usage確認、継続判断 |

---

## 対策9: モデルの使い分け

### サブエージェントのモデル設定

```yaml
model: haiku  # 軽量なタスクはhaikuで
```

| モデル | 用途 | トークン消費 |
|--------|------|-------------|
| opus | 複雑な設計、判断 | 大 |
| sonnet | 通常の開発作業 | 中 |
| haiku | 単純なチェック、フォーマット | 小 |

### 使い分けの例

- **biome-checker**: haiku（単純なコマンド実行）
- **jsdoc-generator**: haiku（パターン化された生成）
- **コードレビュー**: sonnet（判断が必要）
- **アーキテクチャ設計**: opus（複雑な判断）

---

## まとめ

| 対策 | 効果 | 難易度 |
|------|------|--------|
| `/usage` で監視 | ★★★ | 簡単 |
| `/clear` でリセット | ★★★ | 簡単 |
| `/memory` で永続化 | ★★☆ | 普通 |
| claude-mem プラグイン | ★★★ | 普通 |
| Skills/Rules 整備 | ★★★ | 要設計 |
| サブエージェント制限 | ★★☆ | 普通 |
| 効率的な指示 | ★★☆ | 要意識 |
| モデル使い分け | ★☆☆ | 簡単 |

**最も効果的な3つ:**
1. `/usage` で定期的に監視
2. Skills/Rules を整備してコンテキストを最適化
3. サブエージェントの自動呼び出しを控える

レート制限は開発のリズムを崩しますが、適切な運用で回避できます。
この記事を参考に、効率的なClaude Code開発を楽しんでください。

---

## 参考リンク

- [Claude Code 公式ドキュメント](https://docs.anthropic.com/claude-code)
- [claude-mem プラグイン](https://github.com/thedotmack/claude-mem)

---

*この記事は運用しながらブラッシュアップしていく予定です。*
